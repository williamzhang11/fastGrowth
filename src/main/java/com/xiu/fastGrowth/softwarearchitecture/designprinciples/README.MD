# 架构设计原则和规约

架构设计原则，高并发系统设计理念，高可用系统设计，轻量级架构，组件间交互行为

架构师这个行业门规比较多

## 架构设计原则-六大派solid

（single responsibility principle）单一职责
(open closed principle)开闭原则
(loskov substitution prionciple)里氏替换原则
(law of demeter)迪米特法则
(interface segregation principle)接口隔离原则
(dependence inversion principle)依赖倒置原则

### 开放封闭原则

2层含义，分别对应开放和封闭
开放指对扩展开放，封闭是指对修改封闭，新功能是通过扩展形式完成而不是对现有代码修改

如果代码变更或新需求都要对原有的代码修改，那么是侵入式设计，在软件架构层面倡导以扩展形式实现新需求，对于修改来说，对修改关闭。如spring设置个各种各样的扩展点，对自定义功能可以扩展，不用修改它原有的代码，不只是宏观上业务的抽象，也要有微观层面代码的抽象，借助继承扩展特性来实践开闭原则。软件工程中没有银弹，也就是没有一个可以解决所有问题的原则，开闭原则也不是万能解药，对于复杂业务日积月累的修改和增加，曾经微观层面的代码架构之前是可以实践开闭原则的，越来越臃肿，有一个方法重构，代码架构层面的重新设计重新划分，接口和依赖的重新定义，都是重构部分

### 单一职责（专一职责）

混在一起，业务界限不清晰

## 组合与聚合复用原则以及继承

组合由于继承

继承是树状结构，
滥用继承会造成类爆炸，继承滥用违背开闭原则，因为父类的细节变化也会在子类中有所体现，是一种打破封闭性，不论是组合还是聚合都是对持有对象的引用，在业务逻辑内部调用引用对象的方法，这种方式可以降低耦合度，因为可以明确每个对象的职责，不像继承，继承是一种结构化的设计思想，滥用继承不仅会造成类爆炸，也会打破开闭原则，子类和父类之间的耦合比较紧密。指明一个方向，课后顺着这个方向自己体会聚合和组合

组合原则经典运用

继承是树状结构，所有类像叠罗汉一样层层嵌套，组合的层次结构也是树状结构，但是没有继承那么复杂的层次关系

public interface component{

 void add(component c);
 void remove(component c);
 void show();
}

public class Course implements component{

 private String name;

 void add(component c){}
 void remove(component c){}
 public void show(){}
}

public class composit extend component{

    List<component> components = new ArrayList();

    void add(component c){
    	components.add(c);
    }
    void remove(component c){
    	components.remove(c);
    }
    public void show(){

     	components.strean.forEach(Component::show);
    }
	
}

组合方式：
public static void main(String[] args){
	
	Composite suite1 = new Composite("架构师直通车");
	suite1.add(new Course("单体应用"));
	suite1.add(new Course("分布式应用"));

	Composite suite2 = new Composite("架构师二期课程");
	suite2.add(new Course("架构设计"));
	suite2.add(new Course("质量控制"));

	Composite suite3 = new Composite("架构师体系课程");
	suite2.add(suite1);
	suite2.add(suite1);
    suite3.show();
}

不需要关心处理的是单个应用还是组合应用，在组合内加入新的应用很简单那，生命一个新的类就像了，通过扩展添加应用

组合还是继承，当前想要扩展对象是不是一定是超类的完全子类，超类的一举一动都需要完全体现在子类中，这种使用继承，而对于逻辑上没有很强关联关系的类，使用组合


组合原则是一种非常经典的设计模式，《design pattern》,总结了20多种设计模式，他是我们作微观架构的灵感和源泉，各种开源项目都应用了大量的设计模式，所以考察架构师的能力，尤其是代码层面微观架构能力，通常会通过设计模式方向考察，因为代表着技术人员的内功。

聚合对应了很多种设计模式：

迭代器模式（java.util.Iterator），builder(建造者模式 PreparedStatement)，decorator(装饰器模式,Stream输入输出流)，strategy（策略模式，Comparable&Comparator），看学习源码

自己练，学习一门技术，和学习武功差距并不大，怎么学习武功，就2个，第一个，看师傅打一拳（源码），第二，把学到的用到自己项目中，（就像练武一样要实战）。一边看一边学，学技术要自己动手动脑去看，去学，去应用，才能领会其中的深意，如果对于一些知识点不研究，只靠搜索引擎搜索出结果，这就叫练功走火入魔，因为学习过程脱离了自己去研究去实践的环节，根本不知道上下文，搜出来的答案，也根本无法应用到实际项目中，就像学武功一样，搜到了葵花宝典，欲练此功必先自宫，立马练了起来，但问题是问什么这样练，自己要去多练，多体验，多看源码，用到自己项目中，把知识沉淀成自己的营养


高级开发人员也应该脱口而出，哪些类用了这些模式

# 高并发设计原则


## 局部并发原则

同步调用在小的项目中可能合适，但是做一线大厂场景，服务背后可能几十上百的微服务调用

如下单场景：第一获取商品信息（调用商品接口--其内部还有数据聚合信息返回），第二锁定库存（等付款完成后，库存才能真正扣减掉），第三生成付款链接（支付系统调用）第四，获取订单地址信息（地址信息是会变的，下单时地址对应的快照），第五自动手动付款 第六计算优惠信息，第七创建订单，第八生成订单快照（下次来查订单时不需要重新聚合数据，而是直接给快照版信息），第九释放库存/扣减库存（最终一致性，释放也叫补偿），上述步骤全部完成后才会完成下单。

淘系下单链路涉及非常多的微服务，如果采用同步调用，响应时间非常长，商品发布也会是非常长的链路，调用很多微服务做这件事情，这些业务场景本身调用场景很长这是无法改变的，因为系统复杂度高，微服务拆分的比较细，因此在业务中用局部并发原则，在应用中可以同步执行的东西放在起义执行调

第一步：获取商品，获取地址信息，账户信息检查，这三个之间没有依赖关系，可以一次性获取，拿到数据信息后，设置数据检查点。

第二步：生成付款链接，计算优惠信息，锁定库存，设置数据检查点，如果失败了有2种方式可以选择，第一重试，但是需要保证幂等性，第二最终一致性补偿

第三步：生成订单快照，创建订单，释放/扣减库存

但是对于不能用并发处理的，只能同步

自动/手动付款

完成下单

实现方式：异步方式，future接口，遇到数据检查点可以后台用countDown，等jdk中的

自己项目中有更多选择，如响应式编程，异步并发框架，来处理局部并发场景，这种处理更加简介优雅。

 高并发系统是qps（每秒访问量）与RT（）接口响应时间，一般讲，访问量越大，相应的接口处理时间，会被拉长，但是局部并发场景下，会产生博弈，如果都是顺序执行的，某个流程的失败都会阻碍整体流程，但是如果并发执行，如在第一个检查点之前，获取商品信息，获取地址信息，获取账户信息检查，这3个请求同时发出，如果顺序执行，获取商品信息失败了，后面2个并不需要执行，因此高并发系统中应用局部并发策略时，会有意识它有可能增加系统的qps，有可能是有并发策略引起的，可能会让系统qps升高，在压测后对局部并发策略改动，比较建议再压测一次

 
## 服务化拆分

服务化拆分从哪些维度思考

第一个维度，从业务维度出发：商品，订单，库存，营销服务

第二个维度,从功能维度，如营销服务，可以分为2个方向，一个是营销计算规则，第二是营销优惠券，这2个业务属于不同的业务线，从功能上来说拆分开来，再往下细分把营销优惠券的服务，往下分一个粒度，从功能分作，券模板，领券服务，核销服务

第三个维度，资源维度，当我们从资源维度开始拆分时，说明这套系统比较牛逼了，用户量基数已经到达一定层次，这时候从资源维度入手，把一些访问量大的服务隔离出去，如高频场景与低频场景区分（如商品搜索，商品搜索虽然看似是处于产品服务维度，但是他是所有电商场景导流端的入口，访问量非常大）从资源保护出发，不想高频场景影响到低频场景，同样的，IO密集型，如输出输出流的密集型，在发布商品时上传的图片和视频，按理说也是商品服务一部分，但是呢并没有任何业务逻辑，更很多的是耗费更多带宽，进行流媒体传输，或二进制流的传输，这类业务独立出来拆分。计算密集型通常不会涉及过多的输入输出，不会占用过多带宽，但是需要大量的计算资源，也就是内存cpu，隔离这些业务给他们提供足够的资源，不至于他们成为整个链路上的资源瓶颈。

这些服务的拆分主要是未来快速迭代，快速迭代和可扩展性，是其中的一部分，但是一线大厂有个不同的维度看待这个问题，这么做是为了主链路规划，也就是梳理自己的核心链路,对自己微服务拆分的方向和粒度，都有非常强的指导意义


## 高可用设计原则

可用性保证手段：限流，降级，流量切换，弹性计算，回滚

在高可用架构设计时，怎么考虑

降级：如果系统在当前时候不能给出响应，那么退而求其次，将降级后的数据返回，降级分为主动降级或被动降级

主动降级：开关推送（配置中心推送），如当前商品详情页访问压力非常大，那详情页中有一个优惠价格显示，有可能因为压力过大不能很好的响应请求，这时候怎么办呢，这个时候可以人工推送主动降级，可以推送一个开关到app，或者后台服务在渲染详情页时，详情页接口可以绕过营销优惠计算，默认返回一个原价，手机app也可以显示，请到结算页查看优惠信息，这就降级例子。

被动降级：通常接口运行状态有很多维度，比如响应时长超长，在运行期间发生异常，可以采取被动降级，把用户请求导入到降级的业务流程中做返回 或者响应失败率，可以设置一些被动降级规则，熔断保护。如果在请求中超出一定的失败率，可以自动走向降级流程

总之有：超时降级，异常降级，失败率，熔断保护。

降级在业务中怎么玩的呢

多级降级，如果降级中再次发送错误，可能出现二次降级，如业务流程从redis中读取信息，加入redis异常导致读取超时，这时候主动导向第一层降级，可以从local缓存中读取，如果本地没有，导入到二级降级，静默处理（返回默认值），这是一个多级降级的例子，可以思考在核心主链路发生异常时，怎么办，规划降级流程，所有主链路都要思考这样的问题。

限流：网关层限流（nginx，limit模块），服务网关（gateway,redis+lua），除了网关层限流还有业务层限流（本地限流，guava,也叫单机限流），也可以用sentinel组件，进行分布式限流，如何设置限流阈值呢，这个是通过压测测出来的，要把每个模块的负载压出来

抵抗以恶攻击（nginx deny），识别ddos

限流是非常灵活的手段，要根据接口访问量，响应时间动态调整限流策略，访问量RT

弹性计算：弹性机房，利用弹性特性，如下单， 

主搜-》详情页-》购物车-》下单

上述也是主链路，主链路也有一些支线链路。如主搜（直通车排名，全文检索，优惠透出），
详情（用户评论，优惠信息，客服通道）购物车（收藏夹，推荐）

在双11，用户量比之前翻了5-6倍，主链路，扛不住压力，弹性机房，可以用动态弹性伸缩，把关键的计算量压缩，将机器分配给主链路上的环节，通过k8s，和docker。弹性伸缩是必须要做的步骤，还有强调要弹都弹，如果上游链路做了弹性，那么下游链路也要做，容易引发服务雪崩。

流量切换对应多机房环境：

DNS端：dns是输入一个hostname做寻址，这端是流量起点，在域名背后，域名映射匹配规则中做人工切换

client端流量调度（推送））：可以在app中设置这样一种机制，当需要变换流量入口时可以通过推送方式，通过app拉取的方式，从服务配置中心中，拉起新的流量端入口地址。这样在客户端绕过dns，直接访问后台机房地址

虚ip:haproxy(lvs负载均衡)

在应用层也可以做，在高可用手段保障过程中，应用层都有自己的可以配置的（nginx+服务网关），阿里系应用对业务方的要求，三机房多活，至少2个不同城市，他们也会定期进行演练，掐断其中一个机房访问，如果没有做到流量切换和多地多活，那机制就会变得不可用，集团会通过这种方式倒逼高可用

回滚：生产环境中不仅仅指代码回滚，通常指版本控制策略，像配置中心也是代码的一部分，配置中心也要有一定的回滚能力，后台采用配置的地方。还有cicd的pipeline也需要版本控制和回滚，一些bug是不太好用金丝雀测试测试的，经常会出现发布一半，业务出现警告，不得不回滚，依赖于持续集成环境有个部署回滚的功能，回滚到上一个可用版本，在高可用架构中倡导万物都可回滚。

## 保持简单轻量的架构

一些准则是一些单词的缩写：dry,yagni,kiss，都是软件工程中久负盛名的理念，让我们时刻记住，保持轻量级的架构，并且践行在工作和项目中

DRY:donot repeat yourself 减少信息重复， 在自己的项目中，真正大道至简的方法不是添加越来越多的东西，增加越来越臃肿的代码，而是拒绝
诱惑，砍掉不必要的功能，做减法，如果别人有了这个功能，不要去重复做一个新的一模一样的功能，在业务逻辑中尽量把公共的识别出来，抽取公共组件包，一些开发人员非常
喜欢造轮子，热衷造轮子，总以为自己写的才是最适合项目的，有时候不是越勤奋约有效率，而是越懒越有效率，在项目中可用把公共的抽出来，放到一个jar包，让其他人使
用，如审计功能，每个业务都拥有自己做审计功能的,每个公司都有一个基础中间件部门，这个部门存在是为了减少业务部门重复造轮子的资源浪费，有一些工具类，基本上都有
常见的开源项目如：guava,lombok

长code是魔鬼，工作中尽量找一些机会把一些长代码重构掉，还有一些代码审查工具，可用使用。另外长code也会带来重构+设计模式的引入，开源项目通常不是长的代码块而是通过设计模式，将这些功能，分类到各个小的组件中去。

kiss:keep it simple and stupid,往往从架构设计时，往往从设计者视角出发，希望它无所不能，但更多时候应该从使用者角度思考，如何将架构变得简单，易用。手动档vs自动挡，现实是没人买自动挡车子，不要从造物主出发，从实际出发。研发一个框架，一个好的框架：接入无感知，侵入性小（如nacos与eurk），接入成本（是衡量能够推广开的很重要方面，使用约定大于配置理念，clean code《clean code》一本书，当技术能力达到一定层级，往往靠的不是技术，不是术，而是道，心中的架构之道，对代码和架构的感悟和体验，）保持简洁，可用用一句话描述，如果特别复杂，要拆分

YAGNI:you ainot gonna need it:避免过度设计，如果还是单体应用阶段，就考虑分布式事务，或者数据库还是单库时就思考如何做数据有异构，或者在业务逻辑并不复杂的时候，就思考上一个规则引擎，或者现在图形数据库比较火就将图形数据库引入项目中，说好听点是面向简历编程，难听点是脱裤子放屁多此一举，提倡面向未来编程是规划 是取规划技术未来发展路线，当这一天到来时有能力去实现它，而不是把现在不需要的东西把未来搬到现在项目中，很多人都容易犯这种错误，虽然做了很多事情，但是对业务未必有很多帮助，技术服务于业务，如何服务呢，就是功能点没有在业务需求中体现出来， 就不要在代码中体现，避免一项情愿的过度设计。


这些规约都是为了达到简单的目的，try everything you can to keep it simple

## 如何设计组件中的交互和行为

从2个方面第一：命令和查询分离这种理念，第二：关注点分离

CQS:command query separation

查询：获取一个结果，命令是对当前对象状态修改，本身是一个非常上古的架构设计理念。
一方面是一种职责分离，比如接口上查询和修改，从功能上区分开，但在互联网行业访问压力很大，对这种查询/命令这种模式有一种新的认识，现在的查询就是读，命令是写，互联网业务中大部分读多写少。比如读写分离，读库查询请求，读库/写库之间是通过binlog形式同步，可以对读库横向扩展，在超过并发场景下，保护写操作，一旦读库打爆，写库是安全的。

数据异构/聚合---业务数据库如mysql，并发能力是比较弱的 通常做一些异构，比如同步一些数据到es等搜索引擎中间件上来，去做一些数据聚合的查询操作，一份数据冗余在多个地方，这是互联网行业非常常见常见，读写是不同数据源，互联网强调最终一致性。

SOC:separation of concerns

横向业务，纵向结构，无感知三个维度切分关注点

横向业务：服务拆分，模块拆分，从横向功能业务层面，将关注点切分成更小的模块，是单一职责扩展，减少系统间耦合的手段和架构理念

纵向结构：微架构（mvc,manager,dao,repository）将每个功能点放到对应的层次领域中，过去很长一段时间是朝着横业业务拆分和纵向业务划分领域推进精细化发展，随着约定大于配置理念发展壮大，关注点有新维度变化，有一个新的方向

无感知：不是什么都不做，而是把关注点的业务通过无感知方式切入到业务中，如切面（事务，），切面对业务层透明，从业务层分离，以及代理，代理也是，代理数据源，通过代理数据源实现分布式事务框架（seata），从业务分离，spring boot的自动化配置（starter）,spring启动时通过约定大于配置的形式，加载默认配置文件，初始化框架启动项目，达到对业务层无感知，同时将应用启动功能点分离，对业务层侵入越来越少

## 框架层面的发展趋势

也影响到技术选型的选择，

约定大于配置，是一种设计范式，目的很简单可以减少代码量，简单灵活，变更容易，非常方便自定义化，是通过2点达到这种效果的，第一点定制化，第二点默认值，这2点分别对应着共性和个性，隐藏共性突出个性，是这类约定大于配置框架中心思想，如spring boot。

环境变量

application-xxx.yml,对于环境不同加载不同的配置文件

定制化：配置多数据源，就需要额外配置，可以指定不同标签，每个标签时不同的数据源，在声明连接池时，可以通过注解加载指定标签名开头的配置属性，对于既定行为通过默认值，每个starter，都会加载对应的属性，如果属性不存在就会加载默认值，也就是共性的地方

对于技术选型，沿着这个方向，使用约定大于配置里面，如spring data,对于复杂的需求，通过共性和个性满足需求，在更新迭代非常频繁的互联网时代，讲究快，约定大于【配置思想会在很长一段时间占主导地位，轻量级接入，体现在接入成本低，总结为拆箱即用 

## 你的项目的整体架构规划

全局视角：核心模块架构图（组件之间怎么划分的，运用了哪些架构原则）这样可以轻松了解到系统顶层设计

局部视角：你所负责的模块内部分层（架构原则），这些模块上运用了哪些架构原则做设计

可以套用架构设计原则和经典理论，不只是说出这些原则，还要说出为什么这样用

## 高并发业务常见，有哪些思考方向

大前提：微服务化+高可用前提（首要前提），

应用层面:限流+降级熔断+削峰填谷+分库分表+数据异构+分段缓存+局部并发

细节：具体场景举例：读写场景（秒杀说烂了，点赞，关注）

提供一些场景，让你设计高并发架构，需要平常积累

## 水货架构师最爱问--说说你对spring理解

抛掉aop,ioc，可以一笔带过，把理解升华一下，设计理念-插件式（具体举例子）-约定大于配置-等理念层面的具体落地组件

## 公司业务中的高并发场景分析

当前业务中哪些高并发场景，把一些没用的业务加进来

## 我司plaform、infra团队封装的蹩脚工具

最好动手实践

## 每天研究各种技术文章，了解高并发业务的解决方案

红包，春晚红包，全局发号器（订单器生成），秒杀，抢单


# 微服务架构设计基本原则

## 微服务内部代码结构分层

mvc思想的毒害：
微软推荐架构：数据访问层-》业务逻辑层-》ui层
老的mvc:model(service/dao)-> view(页面)->control（control）

mvc不太适合微服务架构了，因为control鸡肋。比如struts时代，loginControl可以控制访问的页面，因为早期是后端控制前端页面的展示的，现在是前端控制，现在control层封装返回对象，封装成标准的返回格式，弱化controller作用，微服务的核心就是服务service,业务逻辑其实是数据服务，从服务角度后台接口是与视图无关的，关注服务本身，自己的业务逻辑，倡导使用json格式返回数据，(statusCode，msg,entity),微服务只关注自身的业务逻辑，其他的都和自己无关。返回数据返回最原始的JSON数据,不用做无畏的封装，也是在阿里系践行的准则，不要方rpc这一层，rpc是单纯的业务数据，在外面包一层，或在网关层对一些特定url访问做一些视图封装。

阿里系的分层，三个主要module,API层，Service层，dao/repo层，api层为什么单独抽出来呢，并不是单纯建一个文件夹，而是抽成一个maven子模块，把api定义到maven中的子module中，因为rpc框架核心是依赖于api,引入api接口层，不仅仅是给service继承的，是给其他上下游调用的，依赖你的api,发起api调用。service层关注自身的业务返回最原始对象，而在实际中通常service层下面，定义manager层。

微服务架构中mvc有点过时，尽量弱化controll作用，不要把视图层概念引入业务逻辑service中，把api层分为单独的子module，作为调用的二方包。

## 从不同维度进行微服务拆分

服务拆分是微服务架构的前戏，决定了微服务改造过程是否顺利，不同维度包括，

压力模型：

第一种：高频高并发流量（用户场景比较频繁，每次发生并发量大）如商品详情页，优惠计算（很多业务都会调用）

第二种：低频突发流量：访问频次不高，但是一旦发生qps也别高，比如批量上架和秒杀，爆款产品

上面2种这种高并发流量的建议做成服务隔离，单独抽取出来做一个微服务模块，目的是，很多考虑点，如把高并发流量和其他普通场景合并起来做成一个微服务，那高并发情况下很容易产生服务雪崩等异常情况的，这样影响高并发场景，以及低频场景也会收到影响，第二点独立出来很方便的做一些流控措施，削峰填谷处理，以及流控手段，商品详情页这种高频高并发流量有时候会出现一些爆款产品出来，他其实是热点数据，单独隔离出来还不够，通常微服务架构设计中把，数据也隔离出来，比如秒杀，预先知道哪些商品参与，是已知的热点数据，对于商品详情页普通场景或者临时突发新闻，通常使用实时的流处理，分析rpc调用上下游的信息，甄别出热点数据，然后触发后台热点隔离策略，怎么做热点隔离呢

1.主链路规划（敲黑板，敲黑板，主链路规划是互联网行业中非常重要的思考方向）什么是主链路规划，就是完成核心交易不得不经过的流程。主链路是战场的正面战场，是需要力
保的阵地，还有一些隐藏的主链路，如营销计算，在搜索，详情，下单中都有，在搜索详情挂掉了不算主链路，下单时，营销优惠计算必不可少，这个链路中是主链路。想表达的
是什么呢，对主链路来说，每一个模块都需要单独抽取出来，这里不要太顾及领域模型，主链路是从业务角度规划的链路，不要因循守旧的运用DDD,这些理论，完全从实际出
发，规划主链路，把每一个服务拆分出来，为什么服务隔离呢，主链路在这场战争中是什么位置呢，是主打的C位输出，把主链路和辅助的隔离开，这样避免边缘业务异常，影响
到主链路。另外一点隔离开来后可以做更细粒度的异常容错，如降级，熔断等，可以通过容错手段对主链路中的异常情况进行精确把控，还有流控，主链路每个环节每个性能瓶颈是什么，容量控制在什么维度都可以做更精粒度的控制，这是拆分主链路成单独微服务的主要原因。弹性计算，在用户量大和小，有伸缩的能力

2.领域模型拆分DDD 

这个是做微服务拆分的主心骨，仅仅团结在领域模型的思维面前不动摇，张飞杨老师讲。

领域模型不仅仅伴随服务的拆分，也伴随服务的合并，微服务规划时，确保微服务之间有清晰的计划

3.根据用户群体维度拆分，如做电商场景，2c,2B是不同的用户群体，即便相同的业务领域，也都有该群里独有的业务场景，这个是二级域。建议先根据主链路和领域模型做一级域划分，然后结合业务场景分析， 着眼于是否从用户领域方向做更细粒度服务拆分

4.还有前后台业务，并不是指页面，前台是下单链路，用户直面的业务场景，对于后台，商家后台，工作人员运营后台，拆分成不同的微服务领域。

在微服务架构领域中没有银弹的 ，适合业务就是最好的 ，白猫黑猫抓住老鼠的就是好猫，适合业务的就是最好的

## 微服务拆分例子--新零售业务微服务拆分路线

业务背景，承担的历史使命。时间紧（快速验证业务模式），任务重（一个月放一天假），责任大（五星战略的首要目标），糙快猛业务模式，需求变更非常频繁，要给产品团队足够的时间，足够灵活度，随时调整业务方向，因此系统架构层面如何体现，这种灵活度，要看微服务拆分功力

业务方的入口：1.终端用户（app终端，手淘导流，线下pos），2.运营团队，运营团队有自己业务系统，管理运行活动， 3.内部工作人员岗位（履约终端）拣货终端，扫码枪

业务需求：商品模块（主链路，新玩法），订单中心（履约），商品模块，库存模块，用户中心，搜索模块，后台运营系统，营销模块，导购投放系统，购物车模块

负责：商品中心，后台运营系统，营销平台

一个模块很多微服务

商品中心：商品发布，上下架，详情页服务，商品搜索，。。。  初期是一个单体应用，初期是业务模式验证的阶段，这么复杂功能后台很多团队一起工作，很容易挂掉。因此需要微服务改造--老城区改造计划

微服务改造有几个维度：下面看从几个微服务角度出发，划分不同的微服务边界的

抗压维度：

低频瞬时流量场景（商品发布服务，库存发布）：后台一键开店，零点库存生效

高频匀速流量（商品详情页，搜索服务）：

热点数据（关注）：热key,热点数据隔离

单独分拆出来。

业务维度：

第一可以根据主链路，第二可以根据不同的业务种类划分

定时任务（改价单，库存发布计划），主链路+前端用户场景（商品详情页，商品搜索服务，广告投放+营销优惠计算领优惠券，购物车/订单页商品信息） 单独拆分，运营场景（商品编辑，预售商品设置，营销规则设置，商品类目编辑，商品发布服务，优惠券模板）
 
指导方针：第一点，根据业务场景不同，做微服务方案的隔离，第二点：剥离高频接口


简图：

淘系中台（集团层面，ic订单，淘系商品，ump,支付系统）-》详情页微服务，商品发布微服务，商品发布微服务（瞬时场景，突然产生大量流量，有2个手段第一：削峰填谷，第二限流，把瞬时流量打散，用rocketmq）,服务淘宝微服务（适配层，由它将具体底层业务方业务对接到集团中台标准业务，对上【屏蔽了底层业务特异性，对下屏蔽了接入的集团复杂度，商品营销微服务，商品导购服务，商品资源位微服务，商品后台批量任务，改价单和库存发布）


微服务非常多，只有在大厂才能实践深入

## 如何理解微服务的无状态化

stateless:

什么是有状态？有上下游依赖的，如单机session-》session存在redis

单机缓存:如热点数据时，分布式缓存顶不住压力，会构建本地缓存方案.用户在访问服务时，通常会根据用户id或者商品id,做一个hash，根据hash值请求路由到哪台机器上，一致性hash,假如一个类似redis中心化缓存获取这些信息，不管路由到哪台机器上，都可以从redis中拿数据，假如你的商品成为热点数据，会通过后台job构建一个本地缓存，这台通过hash路由到服务器上，假设一致性算法发生算法或者集群中添加了新的机器，这样访问请求路由到其他机器，这时候问题出现了，其他机器上没有构建本地缓存，这种是有状态的

微服务设计中强调服务是无状态的，完全从水平扩展看的，有状态服务在扩缩容的过程中受限于上下游的依赖。如何解决有状态服务呢

在数据分发，处理，存储这三个环节，做到一个要求，任意节点可达性，请求不论落在服务器节点的任意服务节点上都可以完成这个任务，每个环节都要考虑扩容的问题。


微服务设计中通常是应用无状态，如商品中心可以任意部署各个节点，配置管理有状态，如商品中心在不同集群配置文件是不一样的，这种不同也是上下文依赖，配置管理的有状态和应用的无状态之间划分隔离，通过配置管理 


## 通过接口版本控制实现向后兼容

代码版本控制，接口也有，微服务架构迭代快，同样业务入口，一般是app,伴随着客户端版本升级，同样伴随业务方向变化，如app1.2,app1.3，app1.4实现下单接口，微服务强调快速迭代快速验证商业模式，在最早期下单接口中实现单品下单，后面支持单门店下单，最后面购物车跨店下单，app虽然升级到1.4但是仍然有用户使用早期版本，对这部分用户来说，必须提供向后兼容的特性，也就是说，老的业务流程，可以通过后台访问，问题是，这3个版本对应的业务逻辑很大不同，如果只提供一个下单接口，在下单接口中如何处理历史包袱呢（if/else，造成接口臃肿，也要保测试完全覆盖，更好的方案是，api version）

兼容老业务，做了业务隔离，对老业务修改不会影响到新的接口逻辑，对新接口逻辑修改也不会影响线上老用户的流程访问，app1.2,1.3,1.4分别访问不同的接口，如v1，v2,v3，通过不同版本号路由不同接口中，如何实现呢

一种通过rpc接口实现的服务治理，对接口控制非常到位，如dubble,在接口定义层面可以定义接口版本，可以通过version字段指定

另一种对http接口，通过访问路径path或者header，简单方式在path,checkoutv1,通过指定不同路径就可以访问，可能比较粗鲁，但是不优雅，第二种实现借助header，客户端发起调用时，指定版本号，可以借助业务网关进行路由（谓词断言），下线的话在网关层下线就行

# 服务可用性保障性手段-流量整形

令牌桶和漏桶，限流是流量整形的一个子集，限流+降级（被限流，达到降级里面）

令牌和桶，2个概念。对于流量整形算法来说主要关注2点，第一点突发流量处理，第二点堆积能力（排队队列，多长时间丢弃，堆积量）


流量整形增强算法--》预热模型---》guava（单机版限流工具）


## 微服务设计中的网关层和分布式限流

网关层特点，中心化，限流不同维度，即四象限：

访问频率表，ip连接数，黑白名单(动态变化，封ip爬虫)，传输速率（上行，下载）

限流规则，一般设置多个，木桶理论

限流应用点：网关层，业务限流，网关层限流资源成本最小，因为如果放在业务层，后台是要有一个判断响应的，决定是否限流，成本最低，但在业务层限流可以做更精细粒度的控制

网关层：一般使用nginx+lua，或f5，压测结果根据业务流程预估

业务层：业务网关，如gateway，zuul,多层网关是必须要的，一般要搭建多层网关系统，每层网关，性能和应用场景不同，如nginx放在最外层做高性能网关转发，不会牵扯太多的业务，到业务网关，可以做更精细粒度的控制，不仅仅是限流，还有降级熔断，谓词判断（路由），每一层网关需要解决的问题是不一样的。也可以接入不同的限流组件（sentinel,redis+lua(自己编写)，单机guava）,网关层和业务层的区别，就是粒度，可以做更精细力度的控制，网关层希望fastfail，高性能网关，不要有过多业务，在业务层对限流的请求做降级和熔断。

网关层限流一般是返回504，超时，或503服务不可用，在业务层可以服务降级抛出500，由前端跳到固定页面，也可以后端200,是降级后的数据。


## EDA事件驱动架构--消息中间件

EDA驱动和一般做法的接口区别在于驱动，一个是事情驱动，另外一种是行为发起方负责调用下游方法

场景：异步处理（生产消费，委托下游执行），跨语言/跨平台，应用解耦，可靠投递（消费者保证消费一次，事务性消息），最终一致性（补偿手段）

虽好但是适可而止，一般接口为主，也有很多不方便，提高了系统间的复杂度，引入了中间层

## EDA驱动账务系统

业务需求，痛点妥协，解决方案

卖家支付包括的子系统（会计账目，报表系统，退款流程），需要业务方配合（跨团队沟通比较麻烦，每一个架构问题都是以大化小的过程，痛点业务方不配合，不给我们喂数据，切分成2部分，捕捉支付事件-》消费事件，业务方不配合但是，数据不会说谎，职责领域划分，event bus和consumer(会计账目，报表系统，退款流程)，拿到数据源（增量同步工具），分层构建，卖家支付-》数据库，使用canal,构建成支付消息，三段论：）

## 微服务的数据一致性--base理论


代表3个不同维度的信息，基本可用：Basically available，软状态：Soft state,最终一致性：Eventually Consistent

基本可用：

凑合用,主链路规划（降级，弹性计算，响应时间（设置规则））一致性上：最终一致性，保证系统功能，软状态也叫中间状态（如2个数据副本（缓存，数据库），业务流程进行修改，变成了数据不一致情况，未来某个节点上回到一直状态，存在中间态。中间数据不一致的状态叫软状态，在最终一致性的状态下，保障系统功能可用，就是保障在中间态的情况下，系统仍然可用提供服务）最终一致性，是包并发必备，都是最终一致性，选择最终一致性实际上是在可用性与一致性做的权衡，稍稍偏向了可用性，保障可用有限，最终一致性，在什么时间点达到最终一直，什么手段达到最终一致

缓存一致性：决定使用缓存都是最终一致，永远存在中间态，（定期失效，定期刷新，写入时采用双删的策略，写入前删一次，写入后删除，对于热点数据为了防止缓存击穿，采用热点主动构建（不删除，使用定时刷新或者后台补偿保障底层数据库一致性））

采用缓存时意识到数据库和缓存存在不一致的时间段。对于非常依赖可靠性，必须保障强一致性业务，不要从缓存中读取数据，如果从缓存中读取数据，要有这样一个意识，通过缓存读取的数据应用的场景一定是对一致性要求不高的场景，比方说，商品详情页，获取商品详情信息，如果短暂存在不一致，对用户场景来说可用容忍，对于保证强一致场景，如库存扣减，顶多可以使用缓存检查库存，真正扣减，是发生在最底层的，数据库层面，除了缓存一致性，还有数据一致性，伴随着分布式事务一致性（阿里seata,AT全局事务回滚，TCC补偿）

BASE是在可用性与一致性权衡，非常切合互联网的高并发，高可用的架构设计，可用性优先，保障可用性前提下，对一致性采用最终一致性方案

## 微服务的数据一致性--幂等性理论

幂等性指在接口调用下涉及增删改查，一次调用和多次调用产生相同的结果，如下单时，产生了订单，手抖了点了2次，仍然是一个订单。对相同的业务操作返回相同的业务操作结果。

为什么强调幂等性呢？第一个原因最终一致性，微服务架构下很多时候都是靠2个手段保证的：补偿和重试，如果业务执行超时了，这时候获得失败信息，会发起一次重试，有可能超时接口还在执行，并且有了接口，如果没有实现幂等性，那么下次重试，有可能重新执行一遍产生不一样的执行 结果。第二个是异常访问，如果没有做好很好的前端控制，可能用户重复点击下单按钮，导致重复下单。

如果保证呢？

insert：如账号注册，业务唯一的约束，如邮箱，如创建订单，订单号是在创建订单时生成的 并没有唯一的业务约束，这种方案采用隐藏表单和分布式锁技术，进入下单页时，后台生成一个隐藏的token,传给前端页面，前端把token附加到表单中作为一个隐藏属性，在用户下单时传到后台，接受到属性时可以使用分布式锁，将这个token加一个锁，第二次下单时，如果使用相同token，当前订单已经被锁住不能重复下单，整体上都是使用业务唯一约束，和隐藏token+分布式锁锁定资源

update:个人信息修改（乐观锁），打开了多个窗口，第一个窗口修改姓名，第二修改性别，第一个修改了名称提交了，第二个修改性别的同时姓名改回来了，没有重新读
数据进行修改操作，采用乐观锁控制，set version+1 where version = xx（每次update+1），这个乐观锁是从后台读取到透传给前
端页面，因为每次都会新增，在后面一个页面，底层服务发现当前乐观锁版本号已经落后，需要重刷页面，控制幂等性，如并发修改：如是带业务主键的，使用业务逐渐上一个分布式锁+DB锁（select xx for update）,把要修改的资源锁定

delete:天然幂等性（带有业务唯一约束），一般不允许执行删除语句，使用update标记删除

select：不需要保证幂等性（扩展到查询领域中，关注数据一致性） 

## 微服务拆分维度

领域模型划分，场景维度（高频，低频），资源维度（io/带宽/计算）

## 突发流量方案

流量整形（限流+预热），每个问题都有关键字，也可以弹性计算，但是不契合

## 微服务一致性

BASE理论（可用性优先），最终一直性，如分布式事务，分布式锁，幂等性保证，补偿


## app升级，接口如何兼容

接口版本（rpc,http）

## 领域模型和业务角度，进行微服务拆分

公司项目入手，市场上应用

## 脱离分布式事务，可以想到多少一致性方案

分布式事务应用没有很多广泛，（成本+复杂度比较高）

## 研究公开技术文章，了解大厂微服务实践（）拆分


领域模型比较理论，但是应用到实践当中会有一些妥协，研究一些公开分享

















