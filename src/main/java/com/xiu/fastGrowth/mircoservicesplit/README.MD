# 微服务如何拆分

https://mp.weixin.qq.com/s/vQEK0KV-sk4_sfvGaK80mQ

## 1.拆分的目的是什么

拆分的本质是为了将复杂的问题简单化，那么我们在单体架构阶段遇到了哪些复杂性问题呢

单体架构好处：

在开发初期，这种架构确实给开发和运维带来了很大的便捷，主要体现在：

开发简单直接，代码和项目集中式管理。
排查问题时只需要排查这个应用就可以了，更有针对性。
只需要维护一个工程，节省维护系统运行的人力成本。


功能越来越多，开发团队的规模越来越大，单体架构的缺陷慢慢体现出来：

单体架构增加了研发的成本抑制了研发效率的提升。比如公司的垂直电商系统团队会被按业务线拆分为不同的组。当如此多的小团队共同维护一套代码和一个系统时，在配合的过程中就会出现问题。不同的团队之间沟通少，假如一个团队需要一个发送短信的功能，那么有的研发同学会认为最快的方式不是询问其他团队是否有现成的，而是自己写一套，但是这种想法是不合适的，会造成功能服务的重复开发。

由于代码部署在一起，每个人都向同一个代码库提交代码，代码冲突无法避免；同时功能之间耦合严重，可能你只是更改了很小的逻辑却导致其它功能不可用，从而在测试时需要对整体功能回归，延长了交付时间。模块之间互相依赖，一个小团队中的成员犯了一个错误，就可能会影响到其它团队维护的服务，对于整体系统稳定性影响很大。

单体架构对于系统的运维也会有很大的影响。想象一下，在项目初期你的代码可能只有几千行，构建一次只需要一分钟，那么你可以很敏捷灵活地频繁上线变更修复问题。但是当你的系统扩充到几十万行甚至上百万行代码的时候，一次构建的过程包括编译、单元测试、打包和上传到正式环境，花费的时间可能达到十几分钟，并且任何小的修改，都需要构建整个项目，上线变更的过程非常不灵活。

| :------ |:------ |
|因素 |单体架构 |微服务架构 | 说明|
| 交付速度|较慢|较快 | 服务拆分后，各个服务可以独立并行开发、测试、部署，交付效率提升，产品的更新速度会更快，用户体验更好。代码规模大，微服务的优势越明显。|
|故障隔离范围 |线程级 | 进程级| 服务独立运行，通过进程的方式隔离，使故障范围得到有效控制、架构变得更简单可靠。根据业务的重要程度划分服务，把核心的业务划分为独立的服务，这样可以从数据库到服务，保持有效的故障隔离，进而保持稳定。|
|整体可用性 |较低 | 更高|微服务架构由于故障范围得到有效隔离，整体可用性更高，降低一点故障对整体的影响。|
| 架构持续演进|困难 |简单 |由于微服务的粒度更小，架构演进的影响面就更小。不存在大规模重构导致的各种问题。微服务架构对架构演进更友好。 |
|沟通效率 |低 |高 |业界普遍认为团队规模越大，沟通效率越低，微服务架构按业务构建全功能团队，把权利下放，不会出现决策瓶颈点，降低沟通规模，提升沟通效率。 |
|技术栈选择 | 受限	| 灵活| 如果某个业务需要独立的技术栈，可以通过服务划分，接口集成的方式实现。例如搜索，技术栈、专业细分领域都不相同，通常采用独立的服务实现。|
|可扩展性 | 受限|灵活 |微服务架构可以根据服务对资源的要求以服务为粒度扩展，符合AKF扩展立方体中的Y轴扩展，而单体架构只能整体扩展，只能做到AKF扩展立方体中的X轴扩展。 |
|可重用性 |低 |高 | 微服务架构可以实现以服务为粒度通过接口共享重用。|
|实现业务复杂性分解难度 |困难 |容易 |微服务架构通过将业务分解为更多的服务，业务边界更清晰，更容易把一个复杂的问题分解为简单的小问题。 |
|产品创新复杂度 |困难 | 容易|微服务架构以服务为粒度独立演进，团队有更多的自主决策权，更多的试错机会，更利于创新。 |
|一致性实现成本 |低 |高 |服务划分后，如果服务A同时调用服务B和服务C，如何保证同时成功或失败？单体架构下的单库事务变成了分布式事务问题。 |
|时延 | 低| 高|	服务划分后，调用次数增加，响应时间必然升高，吞吐量降低，如何弥补。 |
|资源成本	 |低 |高 |	吞吐量的下降意味着要增加更多的资源，对于交付型项目，特别是小规模部署的场景下，是比较致命的。 |
| 关联查询复杂度|简单 |复杂 |微服务架构的一个非常明显的特征就是一个服务所拥有的数据只能通过这个服务的API来访问。通过这种方式来解耦，这样就会带来查询问题。以前通过join就可以满足要求，现在如果需要跨多个服务集成查询就会非常麻烦。 |
| 远程调用|不涉及 |	涉及 |微服务存在更多的远程调用，需要额外考虑序列化、通信协议、数据压缩、服务间的负载均衡、容错等问题。 |
|服务治理 |不涉及 |涉及 |	由于服务数量变多，微服务架构需要额外考虑服务的注册发现、依赖关系、治理等问题。 |
|对开发人员的要求 |低 |高 | 微服务架构更复杂，开发人员端到端负责，既要考虑接口定义，又要考虑数据库设计，对开发人员的水平要求更高。|
|对工具的依赖 |较低 |较高 |	微服务架构中服务的数量较多，使用工具的效果更明显，依赖程度更高。 |
| 运维复杂度|	低 |高 |微服务架构中服务的数量较多，对服务的监控、健康检查要求更高，整体运维复杂度更高。 |

## 什么时候拆分

业务规模：业务模式得到市场的验证，需要进一步加快脚步快速占领市场，这时业务的规模变得越来越大，按产品生命周期来划分（导入期、成长期、成熟期、衰退期）这时一般在成长期阶段。如果是导入期，尽量采用单体架构。

团队规模：一般是团队达到百人的时候。

技术储备：领域驱动设计、注册中心、配置中心、日志系统、持续交付、监控系统、分布式定时任务、CAP 理论、分布式调用链、API 网关等等。
人才储备：精通微服务落地经验的架构师及相应开发同学。

研发效率：研发效率大幅下降，具体问题参加上面拆分目的里提到的。

## 拆分时应该坚守哪些指导原则？

1.单一服务内部功能高内聚低耦合，也就是说每个服务只完成自己职责内的任务，对于不是自己职责的功能交给其它服务来完成

2.闭包原则（CCP），微服务的闭包原则就是当我们需要改变一个微服务的时候，所有依赖都在这个微服务的组件内，不需要修改其他微服务。

3.服务自治、接口隔离原则，尽量消除对其他服务的强依赖，这样可以降低沟通成本，提升服务稳定性。服务通过标准的接口隔离，隐藏内部实现细节。这使得服务可以独立开发、测试、部署、运行，以服务为单位持续交付。

4.持续演进原则，在服务拆分的初期，你其实很难确定服务究竟要拆成什么样，先拿出几个不太重要的功能拆分出一个服务做试验，如果出现故障，则可以减少故障的影响范围

5.拆分的过程尽量避免影响产品的日常功能迭代，也就是说要一边做产品功能迭代，一边完成服务化拆分。比如优先剥离比较独立的边界服务（如短信服务等），从非核心的服务出发减少拆分对现有业务的影响

6.服务接口的定义要具备可扩展性，服务拆分之后，由于服务是以独立进程的方式部署，所以服务之间通信就不再是进程内部的方法调用而是跨进程的网络通信了

7.避免环形依赖与双向依赖，尽量不要有服务之间的环形依赖或双向依赖，原因是存在这种情况说明我们的功能边界没有化分清楚或者有通用的功能没有下沉下来。

8.阶段性合并，随着你对业务领域理解的逐渐深入或者业务本身逻辑发生了比较大的变化，亦或者之前的拆分没有考虑的很清楚，导致拆分后的服务边界变得越来越混乱，这时就要重新梳理领域边界，不断纠正拆分的合理性。

## 拆分的粒度是不是越细越好？

目前很多传统的单体应用再向微服务架构进行升级改造，如果拆分粒度太细会增加运维复杂度，粒度过大又起不到效果

平衡拆分粒度可以从两方面进行权衡，一是业务发展的复杂度，二是团队规模的人数。如上图，它就像弓箭一样，只有当业务复杂度和团队人数足够大的时候，射出的服务拆分粒度这把剑才会飞的更远，发挥出最大的威力。

## 拆分策略

拆分策略可以按功能和非功能维度进行考虑，功能维度主要是划分清楚业务的边界，非功能维度主要考虑六点包括扩展性、复用性、高性能、高可用、安全性、异构性。接下来详细介绍下。

功能维度

功能维度主要是划分清楚业务边界，采用的主要设计方法可以利用 DDD（关于 DDD 的理论知识可以参考网上其它资料），DDD 的战略设计会建立领域模型，可以通过领域模型指导微服务的拆分，主要分四步进行：

第一步，找出领域实体和值对象等领域对象。
第二步，找出聚合根，根据实体、值对象与聚合根的依赖关系，建立聚合。
第三步，根据业务及语义边界等因素，定义限界上下文。
第四步，每一个限界上下文可以拆分为一个对应的微服务，但也要考虑一些非功能因素。

非功能维度

扩展性：区分系统中变与不变的部分，不变的部分一般是成熟的、通用的服务功能，变的部分一般是改动比较多、满足业务迭代扩展性需要的功能，我们可以将不变的部分拆分出来，作为共用的服务，将变的部分独立出来满足个性化扩展需要。同时根据二八原则，系统中经常变动的部分大约只占 20%，而剩下的 80% 基本不变或极少变化，这样的拆分也解决了发布频率过多而影响成熟服务稳定性的问题。

复用性：不同的业务里或服务里经常会出现重复的功能，比如每个服务都有鉴权、限流、安全及日志监控等功能，可以将这些通过的功能拆分出来形成独立的服务，也就是微服务里面的 API 网关。


高性能：将性能要求高或者性能压力大的模块拆分出来，避免性能压力大的服务影响其它服务。常见的拆分方式和具体的性能瓶颈有关，

高可用：将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来，然后重点保证核心服务的高可用。具体拆分的时候，核心服务可以是一个也可以是多个，只要最终的服务数量满足“三个火枪手”的原则就可以。比如针对商家服务，可以拆分一个核心服务一个非核心服务，核心服务供交易服务访问，非核心提供给商家中心访问。

安全性：不同的服务可能对信息安全有不同的要求，因此把需要高度安全的服务拆分出来，进行区别部署，比如设置特定的 DMZ 区域对服务进行分区部署，可以更有针对性地满足信息安全的要求，也可以降低对防火墙等安全设备吞吐量、并发性等方面的要求，降低成本，提高效率。

异构性：对于对开发语言种类有要求的业务场景，可以用不同的语言将其功能独立出来实现一个独立服务。